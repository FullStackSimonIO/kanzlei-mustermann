---
title: 'Build Full Payload Project'
description: 'Orchestriert den kompletten Projekt-Setup mit automatischem Context-Management, Fehlerbehandlung und Progress-Tracking'
globs:
  - "**/*"
alwaysRun: false
---

# Vollst√§ndiger Payload-Projekt-Aufbau

## üéØ Ziel
F√ºhrt alle Setup-Schritte nacheinander aus mit automatischem Context-Management, Validierung zwischen Schritten und detailliertem Progress-Tracking.

---

## üìã PRE-FLIGHT CHECKS

Vor dem Start pr√ºfe:

### 1. Abh√§ngigkeiten
- [ ] Node.js 18+ installiert: `node --version`
- [ ] Git installiert: `git --version`
- [ ] Vercel CLI installiert: `vercel --version`
- [ ] Figma MCP Server konfiguriert

### 2. Zug√§nge
- [ ] GitHub Account eingeloggt: `gh auth status`
- [ ] Vercel Account eingeloggt: `vercel whoami`
- [ ] Figma Access Token in .env.local
- [ ] Neon Account verf√ºgbar

### 3. Umgebung
- [ ] Genug Speicherplatz (min. 2GB frei)
- [ ] Stabile Internetverbindung
- [ ] Keine laufenden Dev-Server

**Falls etwas fehlt:**
- ‚ùå STOPPE den Workflow
- üìã Liste fehlende Abh√§ngigkeiten auf
- üìñ Gebe Setup-Anleitung

---

## üîÑ WORKFLOW SCHRITTE

### PHASE 1: Projekt-Initialisierung
**Gesch√§tzter Zeitbedarf: 5-10 Minuten**

#### Schritt 1.1: Repository Setup
```bash
# F√ºhre aus: setup-project-workflow
> Repository wird geklont
> Secrets werden generiert
> Vercel Blob Storage wird erstellt
> Neon Database wird erstellt
> .env.local wird konfiguriert
```

**Erwartete Ausgabe:**
```
‚úÖ Repository geklont nach: c:\Users\se18218\elisa-frontend
‚úÖ PAYLOAD_SECRET generiert: [32 Zeichen]
‚úÖ Vercel Blob erstellt: elisa-frontend-storage
‚úÖ Neon DB erstellt: elisa-frontend-db
‚úÖ .env.local aktualisiert mit allen Credentials
```

**Validierung nach Schritt 1.1:**
- [ ] Repository existiert in lokalem Ordner
- [ ] .env.local enth√§lt alle ben√∂tigten Variablen:
  - `PAYLOAD_SECRET`
  - `DATABASE_URI`
  - `BLOB_READ_WRITE_TOKEN`
  - `DATABASE_URL`
  - `NEXT_PUBLIC_SERVER_URL`
  - `FIGMA_FILE_KEY`
  - `FIGMA_ACCESS_TOKEN`
- [ ] package.json existiert
- [ ] node_modules Ordner wurde erstellt

**Bei Fehler:**
```typescript
if (error.includes('Repository nicht erreichbar')) {
  console.error('‚ùå GitHub Repository nicht verf√ºgbar');
  console.log('Pr√ºfe:');
  console.log('1. GitHub Authentifizierung: gh auth status');
  console.log('2. Repository URL korrekt');
  console.log('3. Internetverbindung stabil');
  return { success: false, step: '1.1', error };
}

if (error.includes('Vercel Blob')) {
  console.error('‚ùå Vercel Blob konnte nicht erstellt werden');
  console.log('Manuelle Erstellung: https://vercel.com/dashboard/storage');
  return { success: false, step: '1.1', error };
}

if (error.includes('Neon DB')) {
  console.error('‚ùå Neon Database konnte nicht erstellt werden');
  console.log('Manuelle Erstellung: https://console.neon.tech/');
  return { success: false, step: '1.1', error };
}
```

**Context-Management:**
```typescript
// Nach erfolgreichem Abschluss von Schritt 1.1
await clearContext({
  keepFiles: ['.env.local', 'package.json'],
  reason: 'Phase 1 abgeschlossen, Credentials gesichert'
});

console.log('üßπ Context geleert - Phase 1 abgeschlossen');
console.log('üìä Progress: 20% (1/5 Phasen)');
```

---

### PHASE 2: Design-System Setup
**Gesch√§tzter Zeitbedarf: 3-5 Minuten**

#### Schritt 2.1: Tailwind Optimierung
```bash
# F√ºhre aus: optimize-tailwind
> Figma Design-Tokens werden extrahiert
> tailwind.config.mjs wird generiert
> globals.css wird generiert
> Design-Dokumentation wird erstellt
```

**Erwartete Ausgabe:**
```
‚úÖ Figma Design-Tokens extrahiert:
   - 45 Farben
   - 12 Typography-Rules
   - 32 Spacing-Werte
   - 8 Border-Radius-Werte
   - 6 Shadow-Definitionen
‚úÖ tailwind.config.mjs erstellt
‚úÖ src/app/globals.css erstellt
‚úÖ FIGMA_DESIGN_TOKENS.md dokumentiert
‚úÖ Backups erstellt
```

**Validierung nach Schritt 2.1:**
- [ ] tailwind.config.mjs existiert und ist valid
- [ ] src/app/globals.css existiert
- [ ] Keine CSS-Syntax-Fehler
- [ ] Design-Tokens korrekt importiert
- [ ] Backup-Dateien existieren (.backup.timestamp)

**Test:**
```typescript
// Pr√ºfe ob Tailwind Config valid ist
try {
  const config = await import('./tailwind.config.mjs');
  if (!config.default || !config.default.theme) {
    throw new Error('Tailwind Config unvollst√§ndig');
  }
  
  // Pr√ºfe kritische Design-Tokens
  const colors = config.default.theme.extend.colors;
  if (!colors.primary || !colors.background) {
    throw new Error('Kritische Farben fehlen');
  }
  
  console.log('‚úÖ Tailwind Config validiert');
} catch (error) {
  console.error('‚ùå Tailwind Config fehlerhaft:', error);
  
  // Restore Backup
  const backups = fs.readdirSync('.').filter(f => f.includes('tailwind.config.mjs.backup'));
  if (backups.length > 0) {
    const latest = backups.sort().pop();
    fs.copyFileSync(latest, 'tailwind.config.mjs');
    console.log(`üîÑ Backup wiederhergestellt: ${latest}`);
  }
  
  return { success: false, step: '2.1', error };
}
```

**Context-Management:**
```typescript
await clearContext({
  keepFiles: [
    '.env.local',
    'tailwind.config.mjs',
    'src/app/globals.css',
    'FIGMA_DESIGN_TOKENS.md'
  ],
  reason: 'Design-System konfiguriert'
});

console.log('üßπ Context geleert - Phase 2 abgeschlossen');
console.log('üìä Progress: 40% (2/5 Phasen)');
```

---

### PHASE 3: Component Styling
**Gesch√§tzter Zeitbedarf: 2-3 Minuten**

#### Schritt 3.1: Button-Komponenten stylen
```bash
# F√ºhre aus: style-buttons
> Button-Varianten werden aus Figma extrahiert
> Button-Components werden erstellt
> Storybook-Stories werden generiert
```

**Erwartete Ausgabe:**
```
‚úÖ Button-Varianten erstellt:
   - Primary Button
   - Secondary Button
   - Outline Button
   - Ghost Button
   - Destructive Button
   - Icon Button
‚úÖ src/components/ui/button.tsx erstellt
‚úÖ Button.stories.tsx erstellt
‚úÖ Tests erstellt
```

**Validierung nach Schritt 3.1:**
- [ ] Button-Component existiert
- [ ] Alle Varianten verf√ºgbar (primary, secondary, outline, ghost, destructive)
- [ ] TypeScript-Typen korrekt
- [ ] Accessibility (ARIA-Labels, Focus-States)
- [ ] Responsive auf allen Breakpoints

**Test:**
```typescript
// Test Button-Component
import { Button } from '@/components/ui/button';

// Pr√ºfe alle Varianten
const variants = ['default', 'secondary', 'outline', 'ghost', 'destructive'];
const sizes = ['sm', 'default', 'lg', 'icon'];

for (const variant of variants) {
  for (const size of sizes) {
    try {
      render(<Button variant={variant} size={size}>Test</Button>);
      console.log(`‚úÖ Button ${variant}-${size} funktioniert`);
    } catch (error) {
      console.error(`‚ùå Button ${variant}-${size} fehlerhaft:`, error);
      return { success: false, step: '3.1', error };
    }
  }
}

console.log('‚úÖ Alle Button-Varianten validiert');
```

**Context-Management:**
```typescript
await clearContext({
  keepFiles: [
    '.env.local',
    'tailwind.config.mjs',
    'src/app/globals.css',
    'src/components/ui/button.tsx'
  ],
  reason: 'Button-Components fertig'
});

console.log('üßπ Context geleert - Phase 3 abgeschlossen');
console.log('üìä Progress: 60% (3/5 Phasen)');
```

---

### PHASE 4: Navigation Components
**Gesch√§tzter Zeitbedarf: 5-7 Minuten**

#### Schritt 4.1: Navbar bauen
```bash
# F√ºhre aus: build-navbar
> Navbar-Structure aus Figma extrahiert
> Mobile Navigation erstellt
> Desktop Navigation erstellt
> Mega-Menu implementiert (falls vorhanden)
> Search-Integration
```

**Erwartete Ausgabe:**
```
‚úÖ Navbar-Komponenten erstellt:
   - src/Header/Component.tsx aktualisiert
   - src/Header/Nav/index.tsx erstellt
   - src/Header/MobileNav/index.tsx erstellt
   - src/Header/Search/index.tsx erstellt
‚úÖ Responsive Breakpoints implementiert
‚úÖ Accessibility Features hinzugef√ºgt
‚úÖ Animation & Transitions konfiguriert
```

**Validierung nach Schritt 4.1:**
- [ ] Desktop-Navigation funktioniert
- [ ] Mobile-Navigation (Hamburger-Menu) funktioniert
- [ ] Dropdown-Menus √∂ffnen/schlie√üen korrekt
- [ ] Search-Funktion integriert
- [ ] Logo verlinkt auf Homepage
- [ ] Active-State bei aktueller Page
- [ ] Keyboard-Navigation m√∂glich (Tab, Enter, Escape)
- [ ] Screen-Reader-Labels vorhanden

**Test:**
```typescript
// Test Navigation
describe('Navbar', () => {
  it('rendert Desktop-Navigation auf gro√üen Screens', () => {
    setViewport(1920, 1080);
    render(<Header />);
    expect(screen.getByRole('navigation')).toBeVisible();
    expect(screen.queryByRole('button', { name: /menu/i })).not.toBeInTheDocument();
  });
  
  it('rendert Mobile-Navigation auf kleinen Screens', () => {
    setViewport(375, 667);
    render(<Header />);
    expect(screen.getByRole('button', { name: /menu/i })).toBeVisible();
  });
  
  it('√∂ffnet Mobile-Menu beim Klick', async () => {
    setViewport(375, 667);
    render(<Header />);
    const menuButton = screen.getByRole('button', { name: /menu/i });
    await userEvent.click(menuButton);
    expect(screen.getByRole('navigation')).toBeVisible();
  });
  
  it('schlie√üt Menu mit Escape', async () => {
    setViewport(375, 667);
    render(<Header />);
    const menuButton = screen.getByRole('button', { name: /menu/i });
    await userEvent.click(menuButton);
    await userEvent.keyboard('{Escape}');
    expect(screen.queryByRole('navigation')).not.toBeVisible();
  });
});

console.log('‚úÖ Navigation Tests bestanden');
```

**Context-Management:**
```typescript
await clearContext({
  keepFiles: [
    '.env.local',
    'tailwind.config.mjs',
    'src/app/globals.css',
    'src/components/ui/button.tsx',
    'src/Header/**/*'
  ],
  reason: 'Navigation fertiggestellt'
});

console.log('üßπ Context geleert - Phase 4 abgeschlossen');
console.log('üìä Progress: 80% (4/5 Phasen)');
```

---

### PHASE 5: Hero Sections
**Gesch√§tzter Zeitbedarf: 5-7 Minuten**

#### Schritt 5.1: Hero-Komponenten bauen
```bash
# F√ºhre aus: `build-heroe`
> Hero-Layouts aus Figma extrahiert
> Verschiedene Hero-Varianten erstellt
> Responsive Images konfiguriert
> Call-to-Action Buttons integriert
```

**Erwartete Ausgabe:**
```
‚úÖ Alle Hero-Varianten aus dem Figma Design erstellt:
‚úÖ src/heroes/index.tsx erstellt
‚úÖ Responsive f√ºr alle Breakpoints
‚úÖ Performance-Optimierung (lazy loading, WebP)
‚úÖ SEO-Optimierung (Schema.org, Meta-Tags)
```

**Validierung nach Schritt 5.1:**
- [ ] Alle Hero-Varianten rendern korrekt
- [ ] Bilder werden optimiert geladen (Next.js Image)
- [ ] Responsive auf allen Devices
- [ ] Text ist lesbar auf allen Hintergr√ºnden (Contrast Check)
- [ ] CTA-Buttons funktionieren
- [ ] Animationen performen gut (60fps)
- [ ] SEO-Tags vorhanden (h1, meta description)

**Performance-Test:**
```typescript
// Test Performance
import { measurePerformance } from '@/lib/test-utils';

const metrics = await measurePerformance(() => {
  render(<Hero />);
});

console.log('Performance Metrics:');
console.log(`- First Paint: ${metrics.firstPaint}ms`);
console.log(`- Time to Interactive: ${metrics.tti}ms`);
console.log(`- Largest Contentful Paint: ${metrics.lcp}ms`);

// Validiere Performance-Budgets
if (metrics.lcp > 2500) {
  console.warn('‚ö†Ô∏è LCP zu hoch, optimiere Bilder');
}

if (metrics.tti > 3800) {
  console.warn('‚ö†Ô∏è TTI zu hoch, optimiere JavaScript');
}

// Lighthouse Score
const lighthouseScore = await runLighthouse();
console.log(`Lighthouse Score: ${lighthouseScore.performance}/100`);

if (lighthouseScore.performance < 90) {
  console.warn('‚ö†Ô∏è Lighthouse Performance unter 90');
}
```

**Context-Management:**
```typescript
await clearContext({
  keepFiles: [
    '.env.local',
    'tailwind.config.mjs',
    'src/app/globals.css',
    'src/components/ui/**/*',
    'src/Header/**/*',
    'src/heroes/Header1/*'
  ],
  reason: 'Hero-Sections fertig'
});

console.log('üßπ Context geleert - Phase 5 abgeschlossen');
console.log('üìä Progress: 80% (5/6 Phasen)');
```

---

### PHASE 6: Payload Sections
**Gesch√§tzter Zeitbedarf: 15-20 Minuten**

#### Schritt 6.1: PayloadCMS Blocks bauen
```bash
# F√ºhre aus: build-blocks-full
> Alle Komponenten aus Figma extrahiert
> Verschiedene Blocks erfolgreich generiert
> Responsive Images konfiguriert
> Call-to-Action Buttons integriert
```

**Erwartete Ausgabe:**
```
‚úÖ Alle Blocks aus dem Figma Design erstellt:
‚úÖ src/blocks/{blockCategory}/{blockName}Component.tsx erstellt
‚úÖ src/blocks/{blockCategory}/{blockName}config.ts erstellt
‚úÖ src/blocks/{blockCategory}/{blockName}index.ts erstellt
‚úÖ Responsive f√ºr alle Breakpoints
‚úÖ Performance-Optimierung (lazy loading, WebP)
‚úÖ SEO-Optimierung (Schema.org, Meta-Tags)
```

**Validierung nach Schritt 5.1:**
- [ ] Alle Hero-Varianten rendern korrekt
- [ ] Bilder werden optimiert geladen (Next.js Image)
- [ ] Responsive auf allen Devices
- [ ] Text ist lesbar auf allen Hintergr√ºnden (Contrast Check)
- [ ] CTA-Buttons funktionieren
- [ ] Animationen performen gut (60fps)
- [ ] SEO-Tags vorhanden (h1, meta description)

**Performance-Test:**
```typescript
// Test Performance
import { measurePerformance } from '@/lib/test-utils';

const metrics = await measurePerformance(() => {
  render(<Hero />);
});

console.log('Performance Metrics:');
console.log(`- First Paint: ${metrics.firstPaint}ms`);
console.log(`- Time to Interactive: ${metrics.tti}ms`);
console.log(`- Largest Contentful Paint: ${metrics.lcp}ms`);

// Validiere Performance-Budgets
if (metrics.lcp > 2500) {
  console.warn('‚ö†Ô∏è LCP zu hoch, optimiere Bilder');
}

if (metrics.tti > 3800) {
  console.warn('‚ö†Ô∏è TTI zu hoch, optimiere JavaScript');
}

// Lighthouse Score
const lighthouseScore = await runLighthouse();
console.log(`Lighthouse Score: ${lighthouseScore.performance}/100`);

if (lighthouseScore.performance < 90) {
  console.warn('‚ö†Ô∏è Lighthouse Performance unter 90');
}
```

console.log('üßπ Context geleert - Phase 5 abgeschlossen');
console.log('üìä Progress: 100% (6/6 Phasen)');
```

---

## ‚úÖ FINAL VALIDATION

Nach allen Phasen f√ºhre Gesamt-Validierung durch:

### 1. Build-Test
```bash
# Test Production Build
npm run build

# Erwartete Ausgabe:
# ‚úì Compiled successfully
# ‚úì Collecting page data
# ‚úì Generating static pages
# ‚úì Finalizing page optimization
```

**Bei Errors:**
```typescript
if (buildError.includes('Module not found')) {
  console.error('‚ùå Fehlende Dependencies');
  console.log('F√ºhre aus: npm install');
}

if (buildError.includes('Type error')) {
  console.error('‚ùå TypeScript-Fehler');
  console.log('F√ºhre aus: npm run type-check');
}

if (buildError.includes('CSS error')) {
  console.error('‚ùå CSS-Fehler in globals.css');
  console.log('Pr√ºfe: src/app/globals.css');
}
```

### 2. Dev-Server Test
```bash
# Starte Dev-Server
npm run dev

# Warte auf erfolgreichen Start
# ‚úì Ready on http://localhost:3000
```

### 3. Visual Regression Test
```typescript
// Screenshot-Vergleich mit Figma-Design
const pages = [
  '/',
  '/about',
  '/blog',
  '/contact'
];

for (const page of pages) {
  const screenshot = await captureScreenshot(page);
  const figmaDesign = await getFigmaScreenshot(page);
  
  const similarity = compareImages(screenshot, figmaDesign);
  
  if (similarity < 0.95) {
    console.warn(`‚ö†Ô∏è Seite ${page} weicht von Figma ab (${(similarity * 100).toFixed(1)}% √úbereinstimmung)`);
  } else {
    console.log(`‚úÖ Seite ${page} entspricht Figma-Design (${(similarity * 100).toFixed(1)}%)`);
  }
}
```

### 4. Accessibility Audit
```typescript
import { axe } from 'jest-axe';

const results = await axe(document.body);

if (results.violations.length > 0) {
  console.warn(`‚ö†Ô∏è ${results.violations.length} Accessibility-Probleme gefunden:`);
  results.violations.forEach(violation => {
    console.warn(`- ${violation.description}`);
    console.warn(`  Betrifft: ${violation.nodes.length} Elemente`);
  });
} else {
  console.log('‚úÖ Keine Accessibility-Probleme gefunden');
}
```

### 5. Performance Audit
```bash
# Lighthouse CI
npm run lighthouse

# Bundle-Size Check
npm run analyze
```

---

## üìä ABSCHLUSSBERICHT

Generiere detaillierten Bericht:

```markdown
# Projekt-Setup Abschlussbericht

Generiert: ${new Date().toISOString()}

## ‚úÖ Erfolgreich abgeschlossene Phasen

### Phase 1: Projekt-Initialisierung ‚úÖ
- Repository geklont
- Secrets generiert
- Vercel Blob Storage erstellt
- Neon Database erstellt
- .env.local konfiguriert

### Phase 2: Design-System Setup ‚úÖ
- Figma Design-Tokens extrahiert
- Tailwind konfiguriert
- globals.css erstellt
- 45 Farben, 12 Typography-Rules, 32 Spacing-Werte

### Phase 3: Component Styling ‚úÖ
- Button-Komponenten erstellt
- 5 Varianten, 4 Gr√∂√üen
- Accessibility Features implementiert

### Phase 4: Navigation ‚úÖ
- Desktop-Navigation
- Mobile-Navigation
- Search-Integration
- Keyboard-Navigation

### Phase 5: Hero Sections ‚úÖ
- Alle Hero-Varianten von Figma mit dem Namen `Header` darin
- Responsive Images
- Performance-Optimierung
- SEO-Optimierung

### Phase 6: Payload Blocks ‚úÖ
- Alle Komponenten von Figma abgesehen von `Header`, `Navbar`, `Nav`, `Navigation`, `Footer`
- Responsive Images
- Performance-Optimierung
- SEO-Optimierung


## üìà Metriken

### Performance
- Lighthouse Score: ${lighthouseScore}/100
- First Contentful Paint: ${metrics.fcp}ms
- Time to Interactive: ${metrics.tti}ms
- Largest Contentful Paint: ${metrics.lcp}ms

### Code Quality
- TypeScript Errors: 0
- ESLint Warnings: ${eslintWarnings}
- Bundle Size: ${bundleSize}
- Test Coverage: ${testCoverage}%

### Accessibility
- WCAG 2.1 AA Compliance: ‚úÖ
- Axe Violations: ${axeViolations}
- Keyboard Navigation: ‚úÖ
- Screen Reader Support: ‚úÖ

## üéØ Design-Treue

- Farben: 100% √úbereinstimmung
- Typografie: 100% √úbereinstimmung
- Spacing: 100% √úbereinstimmung
- Layout: ${layoutSimilarity}% √úbereinstimmung

## üì¶ Erstellte Dateien

- tailwind.config.mjs
- src/app/globals.css
- src/components/ui/button.tsx
- src/Header/Component.tsx
- src/Header/Nav/index.tsx
- src/Header/MobileNav/index.tsx
- src/heroes//Header1/index.tsx
- FIGMA_DESIGN_TOKENS.md
- PROJECT_SETUP_REPORT.md

## üîê Credentials

Alle Credentials sicher in .env.local gespeichert:
- ‚úÖ PAYLOAD_SECRET
- ‚úÖ DATABASE_URI
- ‚úÖ BLOB_READ_WRITE_TOKEN
- ‚úÖ DATABASE_URL
- ‚úÖ FIGMA_ACCESS_TOKEN

## üöÄ N√§chste Schritte

1. F√ºhre Tests aus: `npm test`
2. Starte Dev-Server: `npm run dev`
3. √ñffne http://localhost:3000
4. Pr√ºfe visuelle √úbereinstimmung mit Figma
5. Teste auf verschiedenen Devices
6. Deploy zu Vercel: `vercel --prod`

## üíæ Backups

Alle kritischen Dateien wurden gesichert:
- tailwind.config.mjs.backup.${timestamp}
- globals.css.backup.${timestamp}

## ‚è±Ô∏è Gesamtdauer

Start: ${startTime}
Ende: ${endTime}
Dauer: ${duration} Minuten

---

‚úÖ Projekt vollst√§ndig aufgebaut und validiert!
```

---

## üêõ GLOBALE FEHLERBEHANDLUNG

### Automatisches Rollback bei kritischen Fehlern

```typescript
class WorkflowError extends Error {
  constructor(
    public step: string,
    public phase: string,
    public originalError: Error,
    public rollbackable: boolean = true
  ) {
    super(`Fehler in ${phase} - ${step}: ${originalError.message}`);
  }
}

async function executeWorkflow() {
  const checkpoints: Checkpoint[] = [];
  
  try {
    // Phase 1
    const phase1 = await executePhase1();
    checkpoints.push({ phase: 1, files: [...] });
    
    // Phase 2
    const phase2 = await executePhase2();
    checkpoints.push({ phase: 2, files: [...] });
    
    // Phase 3
    const phase3 = await executePhase3();
    checkpoints.push({ phase: 3, files: [...] });
    
    // Phase 4
    const phase4 = await executePhase4();
    checkpoints.push({ phase: 4, files: [...] });
    
    // Phase 5
    const phase5 = await executePhase5();
    checkpoints.push({ phase: 5, files: [...] });
    
  } catch (error) {
    if (error instanceof WorkflowError) {
      console.error(`\n‚ùå KRITISCHER FEHLER IN ${error.phase}\n`);
      console.error(`Schritt: ${error.step}`);
      console.error(`Fehler: ${error.originalError.message}\n`);
      
      if (error.rollbackable) {
        console.log('üîÑ F√ºhre Rollback durch...\n');
        
        // Rollback zu letztem stabilen Checkpoint
        const lastCheckpoint = checkpoints[checkpoints.length - 1];
        await rollbackToCheckpoint(lastCheckpoint);
        
        console.log(`‚úÖ Rollback zu Phase ${lastCheckpoint.phase} erfolgreich`);
        console.log(`üìã Du kannst ab Phase ${lastCheckpoint.phase + 1} fortfahren`);
      } else {
        console.error('‚ùå Rollback nicht m√∂glich - Manuelles Eingreifen erforderlich');
        console.log('\nFehleranalyse:');
        console.log(error.originalError.stack);
      }
      
      // Generiere Fehlerbericht
      await generateErrorReport(error, checkpoints);
    }
  }
}
```

---

## üìù LOGGING & MONITORING

```typescript
// Detailliertes Logging f√ºr jeden Schritt
class WorkflowLogger {
  private logs: LogEntry[] = [];
  
  log(level: 'info' | 'warn' | 'error', message: string, meta?: any) {
    const entry = {
      timestamp: new Date().toISOString(),
      level,
      message,
      meta
    };
    
    this.logs.push(entry);
    
    // Console-Ausgabe mit Farben
    const colors = {
      info: '\x1b[36m',    // Cyan
      warn: '\x1b[33m',    // Yellow
      error: '\x1b[31m',   // Red
      reset: '\x1b[0m'
    };
    
    console.log(`${colors[level]}[${level.toUpperCase()}] ${message}${colors.reset}`);
    
    if (meta) {
      console.log(JSON.stringify(meta, null, 2));
    }
  }
  
  async saveToFile() {
    const filename = `workflow-log-${Date.now()}.json`;
    await fs.writeFile(filename, JSON.stringify(this.logs, null, 2));
    console.log(`\nüìÑ Log gespeichert: ${filename}`);
  }
}

const logger = new WorkflowLogger();
```

---

## üéØ VERWENDUNG

### Automatischer Modus
```
In Cursor AI: Cmd+K ‚Üí "Build Full Payload Project"

Der komplette Workflow wird automatisch ausgef√ºhrt.
```

### Schrittweiser Modus
```typescript
// F√ºhre einzelne Phasen aus
await executePhase(1); // Projekt-Initialisierung
await executePhase(2); // Design-System
await executePhase(3); // Component Styling
await executePhase(4); // Navigation
await executePhase(5); // Hero Sections
```

### Recovery-Modus
```typescript
// Bei Abbruch von bestimmter Phase fortsetzen
await resumeFrom(phase: 3);
```

---

## ‚ú® OPTIMIERUNGEN

### 1. Parallelisierung wo m√∂glich
```typescript
// Unabh√§ngige Tasks parallel ausf√ºhren
await Promise.all([
  generateSecrets(),
  installDependencies(),
  setupGitHooks()
]);
```

### 2. Caching
```typescript
// Cache Figma Design-Tokens
const cache = new Map();
if (cache.has('figma-tokens')) {
  tokens = cache.get('figma-tokens');
} else {
  tokens = await fetchFigmaTokens();
  cache.set('figma-tokens', tokens);
}
```

### 3. Inkrementelle Builds
```typescript
// Nur ge√§nderte Dateien neu bauen
const changedFiles = await getChangedFiles();
if (changedFiles.includes('tailwind.config.mjs')) {
  await rebuildCSS();
}
```

---

‚úÖ **Workflow vollst√§ndig optimiert und produktionsbereit!**