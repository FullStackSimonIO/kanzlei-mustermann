---
description: Alle Hero Komponenten aus geklontem Relume Repo laden und konvertieren
---

# Schritt 3: Heroes erstellen

## Input
- Build Config: `.temp/build-config.json`

## WICHTIG: Naming Convention

**Relume Repo:** Alle Hero-Komponenten hei√üen `HeroHeader{N}` im Ordner `Header/`
**Input Props:** K√∂nnen sein:
- `Header1` ‚Üí wurde zu `HeroHeader1` normalisiert
- `HeroHeader5` ‚Üí bleibt `HeroHeader5`

## Aufgaben

### 1. Alle Hero Komponenten aus geklontem Repo laden

```bash
echo "üì• Lade Hero Komponenten..."

BUILD_CONFIG=$(cat .temp/build-config.json)
HERO_COUNT=$(echo $BUILD_CONFIG | jq '.components.heroes | length')

mkdir -p .temp/relume-components/heroes

echo "Lade $HERO_COUNT Heroes..."

for i in $(seq 0 $(($HERO_COUNT - 1))); do
  HERO_NAME=$(echo $BUILD_CONFIG | jq -r ".components.heroes[$i].name")
  HERO_PATH=$(echo $BUILD_CONFIG | jq -r ".components.heroes[$i].localPath")
  
  if [ ! -f "$HERO_PATH" ]; then
    echo "‚ùå Hero nicht gefunden: $HERO_NAME ($HERO_PATH)"
    exit 1
  fi
  
  cp "$HERO_PATH" ".temp/relume-components/heroes/${HERO_NAME}.tsx"
  echo "‚úÖ Geladen: $HERO_NAME"
done

echo "‚úÖ Alle $HERO_COUNT Heroes geladen"
```

### 2. Alle Heroes analysieren

```typescript
const buildConfig = JSON.parse(
  fs.readFileSync('.temp/build-config.json', 'utf-8')
);

const heroAnalysis = [];

for (const hero of buildConfig.components.heroes) {
  const heroCode = fs.readFileSync(
    `.temp/relume-components/heroes/${hero.name}.tsx`,
    'utf-8'
  );
  
  const analysis = {
    name: hero.name,
    originalName: hero.originalName,
    hasImage: heroCode.includes('img') || heroCode.includes('Image'),
    hasVideo: heroCode.includes('video') || heroCode.includes('Video'),
    hasFeatures: heroCode.includes('feature') || heroCode.includes('Feature'),
    hasStats: heroCode.includes('stat') || heroCode.includes('number'),
    buttonCount: (heroCode.match(/button|Button/gi) || []).length,
    hasTestimonial: heroCode.includes('testimonial') || heroCode.includes('quote'),
    hasForm: heroCode.includes('form') || heroCode.includes('input'),
  };
  
  heroAnalysis.push(analysis);
  console.log(`‚úÖ Analysiert: ${hero.name}`);
}

fs.writeFileSync(
  '.temp/analysis/heroes-analysis.json',
  JSON.stringify(heroAnalysis, null, 2)
);

console.log(`‚úÖ Alle ${heroAnalysis.length} Heroes analysiert`);
console.log(JSON.stringify(heroAnalysis, null, 2));
```

### 3. Shared Hero Block Config erstellen

```typescript
// filepath: src/heroes/config.ts
import type { Block } from 'payload'

// Lade Hero Analysis f√ºr conditional fields
const heroAnalysis = JSON.parse(
  fs.readFileSync('.temp/analysis/heroes-analysis.json', 'utf-8')
);

export const HeroBlock: Block = {
  slug: 'hero',
  labels: {
    singular: 'Hero Sektion',
    plural: 'Hero Sektionen',
  },
  fields: [
    {
      name: 'heroType',
      type: 'select',
      label: 'Hero Typ',
      required: true,
      admin: {
        description: 'W√§hle den Stil der Hero-Sektion',
      },
      options: heroAnalysis.map(hero => ({
        label: hero.name.replace(/([A-Z])/g, ' $1').trim(),
        value: hero.name.charAt(0).toLowerCase() + hero.name.slice(1),
      })),
    },
    {
      name: 'heading',
      type: 'text',
      label: 'Haupt√ºberschrift',
      required: true,
      admin: {
        description: 'Die gro√üe √úberschrift der Hero-Sektion',
      },
    },
    {
      name: 'subheading',
      type: 'richText',
      label: 'Unter√ºberschrift',
      admin: {
        description: 'Beschreibungstext unter der Haupt√ºberschrift',
      },
    },
    {
      name: 'image',
      type: 'upload',
      relationTo: 'media',
      label: 'Bild',
      admin: {
        description: 'Haupt-Bild der Hero-Sektion',
        condition: (data) => {
          const heroesWithImage = heroAnalysis
            .filter(h => h.hasImage)
            .map(h => h.name.charAt(0).toLowerCase() + h.name.slice(1));
          return heroesWithImage.includes(data.heroType);
        },
      },
    },
    {
      name: 'backgroundVideo',
      type: 'upload',
      relationTo: 'media',
      label: 'Hintergrund-Video',
      admin: {
        description: 'Video als Hintergrund',
        condition: (data) => {
          const heroesWithVideo = heroAnalysis
            .filter(h => h.hasVideo)
            .map(h => h.name.charAt(0).toLowerCase() + h.name.slice(1));
          return heroesWithVideo.includes(data.heroType);
        },
      },
    },
    {
      name: 'buttons',
      type: 'array',
      label: 'Call-to-Action Buttons',
      maxRows: 3,
      admin: {
        description: 'Aktions-Buttons (max. 3)',
      },
      fields: [
        {
          name: 'text',
          type: 'text',
          label: 'Button Text',
          required: true,
        },
        {
          name: 'link',
          type: 'group',
          label: 'Link',
          fields: [
            {
              name: 'type',
              type: 'select',
              options: [
                { label: 'Interne Seite', value: 'page' },
                { label: 'Externe URL', value: 'url' },
              ],
              defaultValue: 'page',
            },
            {
              name: 'page',
              type: 'relationship',
              relationTo: 'pages',
              admin: {
                condition: (_, siblingData) => siblingData?.type === 'page',
              },
            },
            {
              name: 'url',
              type: 'text',
              admin: {
                condition: (_, siblingData) => siblingData?.type === 'url',
              },
            },
          ],
        },
        {
          name: 'variant',
          type: 'select',
          label: 'Button Stil',
          admin: {
            description: 'W√§hle den Stil des Buttons (ShadCN Variant)',
          },
          options: [
            { label: 'Standard (gef√ºllt)', value: 'default' },
            { label: 'Outline', value: 'outline' },
            { label: 'Ghost (transparent)', value: 'ghost' },
            { label: 'Link', value: 'link' },
          ],
          defaultValue: 'default',
        },
      ],
    },
    {
      name: 'features',
      type: 'array',
      label: 'Feature-Liste',
      admin: {
        description: 'Liste von Features oder Vorteilen',
        condition: (data) => {
          const heroesWithFeatures = heroAnalysis
            .filter(h => h.hasFeatures)
            .map(h => h.name.charAt(0).toLowerCase() + h.name.slice(1));
          return heroesWithFeatures.includes(data.heroType);
        },
      },
      fields: [
        {
          name: 'icon',
          type: 'upload',
          relationTo: 'media',
          label: 'Icon',
        },
        {
          name: 'title',
          type: 'text',
          label: 'Titel',
        },
        {
          name: 'description',
          type: 'textarea',
          label: 'Beschreibung',
        },
      ],
    },
    {
      name: 'stats',
      type: 'array',
      label: 'Statistiken',
      maxRows: 4,
      admin: {
        description: 'Zahlen und Statistiken',
        condition: (data) => {
          const heroesWithStats = heroAnalysis
            .filter(h => h.hasStats)
            .map(h => h.name.charAt(0).toLowerCase() + h.name.slice(1));
          return heroesWithStats.includes(data.heroType);
        },
      },
      fields: [
        {
          name: 'number',
          type: 'text',
          label: 'Zahl',
          required: true,
        },
        {
          name: 'label',
          type: 'text',
          label: 'Beschriftung',
          required: true,
        },
      ],
    },
    {
      name: 'testimonial',
      type: 'group',
      label: 'Testimonial',
      admin: {
        condition: (data) => {
          const heroesWithTestimonial = heroAnalysis
            .filter(h => h.hasTestimonial)
            .map(h => h.name.charAt(0).toLowerCase() + h.name.slice(1));
          return heroesWithTestimonial.includes(data.heroType);
        },
      },
      fields: [
        {
          name: 'quote',
          type: 'textarea',
          label: 'Zitat',
        },
        {
          name: 'author',
          type: 'text',
          label: 'Autor',
        },
        {
          name: 'role',
          type: 'text',
          label: 'Position/Rolle',
        },
        {
          name: 'avatar',
          type: 'upload',
          relationTo: 'media',
          label: 'Foto',
        },
      ],
    },
  ],
}
```

### 4. Einzelne Hero Komponenten erstellen

```bash
echo "üìù Erstelle Hero Komponenten..."

BUILD_CONFIG=$(cat .temp/build-config.json)
HERO_COUNT=$(echo $BUILD_CONFIG | jq '.components.heroes | length')

mkdir -p src/heroes

for i in $(seq 0 $(($HERO_COUNT - 1))); do
  HERO_NAME=$(echo $BUILD_CONFIG | jq -r ".components.heroes[$i].name")
  HERO_DIR="src/heroes/${HERO_NAME}"
  
  mkdir -p "$HERO_DIR"
  
  echo "Creating $HERO_DIR/index.tsx..."
done

echo "‚úÖ Hero Komponenten Ordner erstellt"
```

F√ºr jede Hero:

```typescript
// filepath: src/heroes/{HeroName}/index.tsx
'use client'

import React from 'react'
import type { HeroBlock as HeroBlockType } from '@/payload-types'
import { Button } from '@/components/ui/button'
import { RichText } from '@/components/RichText'
import { Media } from '@/components/Media'
import { CMSLink } from '@/components/CMSLink'

interface {HeroName}Props {
  data: HeroBlockType
}

export const {HeroName}: React.FC<{HeroName}Props> = ({ data }) => {
  // WICHTIG: Original Relume Code aus .temp/relume-components/heroes/{HeroName}.tsx
  // hier einf√ºgen und NUR Datenquelle √§ndern!
  // Alle Tailwind Classes beibehalten
  // Buttons NUR mit ShadCN Variants
  
  return (
    <section className="px-[5%] py-16 md:py-24 lg:py-28">
      <div className="container">
        <div className="grid grid-cols-1 gap-x-20 gap-y-12 md:gap-y-16 lg:grid-cols-2 lg:items-center">
          {/* Content */}
          <div>
            <h1 className="mb-5 text-6xl font-bold md:mb-6 md:text-9xl lg:text-10xl">
              {data.heading}
            </h1>
            <div className="md:text-md">
              <RichText content={data.subheading} />
            </div>
            
            {/* Buttons - NUR ShadCN Variants! */}
            {data.buttons && data.buttons.length > 0 && (
              <div className="mt-6 flex flex-wrap gap-4 md:mt-8">
                {data.buttons.map((button, index) => (
                  <Button
                    key={index}
                    variant={button.variant}
                    asChild
                  >
                    <CMSLink {...button.link}>
                      {button.text}
                    </CMSLink>
                  </Button>
                ))}
              </div>
            )}
            
            {/* Features (conditional) */}
            {data.features && data.features.length > 0 && (
              <div className="mt-10 grid grid-cols-1 gap-6 sm:grid-cols-2">
                {data.features.map((feature, index) => (
                  <div key={index} className="flex gap-4">
                    {feature.icon && (
                      <Media resource={feature.icon} className="h-6 w-6" />
                    )}
                    <div>
                      <h3 className="font-semibold">{feature.title}</h3>
                      <p className="text-sm text-muted-foreground">
                        {feature.description}
                      </p>
                    </div>
                  </div>
                ))}
              </div>
            )}
            
            {/* Stats (conditional) */}
            {data.stats && data.stats.length > 0 && (
              <div className="mt-10 grid grid-cols-2 gap-8 md:grid-cols-4">
                {data.stats.map((stat, index) => (
                  <div key={index}>
                    <div className="text-4xl font-bold">{stat.number}</div>
                    <div className="text-sm text-muted-foreground">
                      {stat.label}
                    </div>
                  </div>
                ))}
              </div>
            )}
          </div>
          
          {/* Media */}
          <div>
            {data.image && (
              <Media 
                resource={data.image} 
                className="w-full object-cover rounded-lg"
              />
            )}
            {data.backgroundVideo && (
              <Media 
                resource={data.backgroundVideo} 
                className="w-full object-cover rounded-lg"
              />
            )}
          </div>
        </div>
        
        {/* Testimonial (conditional) */}
        {data.testimonial && (
          <div className="mt-16 text-center">
            <blockquote className="text-xl italic">
              "{data.testimonial.quote}"
            </blockquote>
            <div className="mt-4 flex items-center justify-center gap-4">
              {data.testimonial.avatar && (
                <Media 
                  resource={data.testimonial.avatar} 
                  className="h-12 w-12 rounded-full"
                />
              )}
              <div className="text-left">
                <div className="font-semibold">{data.testimonial.author}</div>
                <div className="text-sm text-muted-foreground">
                  {data.testimonial.role}
                </div>
              </div>
            </div>
          </div>
        )}
      </div>
    </section>
  )
}
```

### 5. Hero Renderer erstellen

```typescript
// filepath: src/heroes/index.tsx
'use client'

import React from 'react'
import type { HeroBlock as HeroBlockType } from '@/payload-types'

// Import all heroes dynamisch aus build config
const buildConfig = JSON.parse(
  fs.readFileSync('.temp/build-config.json', 'utf-8')
);

${buildConfig.components.heroes.map(hero => 
  `import { ${hero.name} } from './${hero.name}'`
).join('\n')}

export const HeroComponents = {
  ${buildConfig.components.heroes.map(hero => {
    const camelCase = hero.name.charAt(0).toLowerCase() + hero.name.slice(1);
    return `${camelCase}: ${hero.name}`;
  }).join(',\n  ')}
}

interface HeroRendererProps {
  data: HeroBlockType
}

export const HeroRenderer: React.FC<HeroRendererProps> = ({ data }) => {
  const Component = HeroComponents[data.heroType]
  
  if (!Component) {
    console.warn(`Hero type "${data.heroType}" not found`)
    return null
  }
  
  return <Component data={data} />
}
```

### 6. Migration erstellen

```bash
echo "üìù Erstelle Migration f√ºr Hero Block..."
npm run payload migrate:create -- --name add-hero-block

echo "üîÑ F√ºhre Migration aus..."
npm run payload migrate

if [ $? -eq 0 ]; then
  echo "‚úÖ Migration erfolgreich ausgef√ºhrt"
else
  echo "‚ùå Migration fehlgeschlagen"
  exit 1
fi
```

### 7. In payload.config.ts registrieren

```typescript
// filepath: src/payload.config.ts
// ...existing code...
import { Header } from './Header/config'
import { Footer } from './Footer/config'
import { HeroBlock } from './heroes/config'

export default buildConfig({
  // ...existing code...
  collections: [
    {
      slug: 'pages',
      // ...existing code...
      fields: [
        {
          name: 'layout',
          type: 'blocks',
          blocks: [
            HeroBlock,
            // ...existing code...
          ],
        },
      ],
    },
  ],
  globals: [
    Header,
    Footer,
    // ...existing code...
  ],
})
```

### 8. Git Commit

```bash
BUILD_CONFIG=$(cat .temp/build-config.json)
HERO_LIST=$(echo $BUILD_CONFIG | jq -r '.components.heroes[].originalName' | tr '\n' ', ' | sed 's/,$//')
HERO_COUNT=$(echo $BUILD_CONFIG | jq '.components.heroes | length')

git add src/heroes/
git add src/payload.config.ts
git add src/migrations/

git commit -m "feat(heroes): add ${HERO_COUNT} hero sections

Source: HeroHeader*.tsx from cloned Relume repo
Heroes: ${HERO_LIST}

Components:
$(echo $BUILD_CONFIG | jq -r '.components.heroes[] | "- \(.name) (from \(.originalName))"')

Features:
‚úÖ Shared config.ts with smart conditional fields
‚úÖ Individual components in src/heroes/{HeroName}/
‚úÖ HeroRenderer for dynamic rendering
‚úÖ Original Relume designs preserved
‚úÖ All Tailwind classes maintained
‚úÖ ShadCN Button variants (default, outline, ghost, link)
‚úÖ Conditional fields based on hero type
‚úÖ German PayloadCMS labels
‚úÖ Migration executed successfully
‚úÖ Registered in payload.config.ts

No custom styles - pure ShadCN components!"

echo "‚úÖ Git Commit erstellt"
```

## Erfolgskriterien

- [ ] Alle Heroes erfolgreich aus Repo geladen
- [ ] Namen korrekt normalisiert (Header1 ‚Üí HeroHeader1)
- [ ] Alle Heroes analysiert
- [ ] Shared config.ts mit smart conditionals erstellt
- [ ] Jede Hero hat eigene Komponente in /heroes/{HeroName}/
- [ ] HeroRenderer funktioniert
- [ ] Nur ShadCN Button Variants verwendet (keine Custom-Styles!)
- [ ] Alle Tailwind Classes exakt beibehalten
- [ ] Nur Datenquelle ge√§ndert (hardcoded ‚Üí data props)
- [ ] Migration erfolgreich ausgef√ºhrt
- [ ] In payload.config.ts registriert
- [ ] Git Commit erstellt

## N√§chster Schritt
`.cursor/commands/04-create-blocks.mdc`